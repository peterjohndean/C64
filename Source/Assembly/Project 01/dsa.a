; ------------------------------------------------------------
;  BASIC Variable/Array Storage Area
;  ------------------------------------------------------------
;  Dumps the BASIC variable/array names and type.
;	- VARTAB to ARYTAB (Each entry is 7 bytes)
;	- ARYTAB to STREND (Each entry varys in length)
;
;  - Destroys A,X,Y & MM_FREKZP
;  - Outputs: iteration index + var name (var type)
; ------------------------------------------------------------
!zone DUMPBASICSTORAGEAREA {

; Declarations
!address Index	= <MM_FREKZP+2		; Force Page-0/Zero
!address Ptr1	= <MM_FREKZP		; Force Page-0/Zero
!address Ptr2 	!word 0
!address Ptr3	!word 0			; Temporary 16-bit value.
!address Bool	!byte 0			; 0 = VARTAB, else ARYTAB

; Variable Types
!address .STRfloat	!pet " (float)", 0
!address .STRstring	!pet " (string)", 0
!address .STRint	!pet " (int)", 0
!address .STRfn		!pet " (fn)", 0
!address .STRTable	!word .STRfloat, .STRstring, .STRfn, .STRint	; Sequence is important!

EntryPoint_DBSA
	jsr DVSA			; Output variable storage area
    jsr BASIC_GOCR		; Newline
	jsr DASA			; Output array storage area
	
ExitPoint_DBSA:
	rts
	
; Very simple dump variable name table
DumpTable:
; Main loop
.loop:
	+CMP16 Ptr1, Ptr2
	bcs ExitPoint_DBSA	; Exit, if Ptr1 â‰¥ Ptr2
	
.cont:
    ; Display:
    ; Variable sequence index, Variable name, Variable type
    ; xx. nn (type)
    +BASIC_LINPRT Index
	+KERNEL_CHROUT '.'
    +KERNEL_CHROUT ' '

    ;
    ; Display:
    ; Variable name (2 character max.)
    ; e.g.
    ;  A
    ; AA
    
    ; Is there a 2nd character in the name?
    ldy #1
    lda (Ptr1),y
    and #$7f			; Handle $80 as terminator
    beq .No2ndChar		; Branch if 0 OR $80
    
    ; Output x2 character name
    dey
    lda (Ptr1),y
    and #$7f
    jsr KERNEL_CHROUT	; Output first character
    iny
    lda (Ptr1),y
    and #$7f
    jsr KERNEL_CHROUT	; Output second character
    
    jmp TypeDetect		; Now what type of variable is it?
    
.No2ndChar
	; Output x1 character name
	+KERNEL_CHROUT ' '	; Output leading space
    dey
    lda (Ptr1),y
    and #$7f
    jsr KERNEL_CHROUT	; Output first character
    
    jmp TypeDetect		; Now what type of variable is it?
    
.next:
	
	inc Index			; Increment variable sequence index
    jsr BASIC_GOCR		; Newline

	;
	; Handle Variables & Arrays differently
	lda Bool
	bne .ARYTAB			; Bool == 0, fallthrough to .VARTAB, else branch to .ARYTAB
	
.VARTAB:
    jsr .add7
    jmp .loop
    
.ARYTAB:
	jsr .addtoPtr1
    jmp .loop
    
; ------------------------------------------------------------
;  BASIC storage variable type
; ------------------------------------------------------------ 
; Ptr1		Ptr1+1
; LSB		MSB	
; & $80		& $80	Index	BASIC Variable Type
; 0			0		0 (00)	Float
; 0			1		1 (01)	String
; 1			0		2 (10)	Function
; 1			1		3 (11)	Integer	
; ------------------------------------------------------------
TypeDetect:
    ; Calculate type index (0-3) and multiply by 2 for word table
    ldy #0
    lda (Ptr1),y
    and #$80
    rol             ; Shift LSB bit 7 into carry
    				; Reference:
    				; - pg 3-85, 6502 Assembly Language Programming, 1979, Lance A. Leventhal
    				; - pg64-65,pg259, 6502 Software Design, 1980, Leo J. Scanlon
    ldy #1  
    lda (Ptr1),y
    and #$80
    rol             ; Shift MSB bit 7 into carry, previous carry into bit 0
    rol             ; Now A contains 0-3
    and #$03
    asl             ; Multiply by 2 for word table index
    tay
    
    ; Preserve 0/Zero-Page
    lda Ptr1
    pha
    lda Ptr1+1
    pha
    
    ; Look up string pointer from table
    lda .STRTable,y		; lsb
    pha
    lda .STRTable+1,y	; msb
    tay
    pla
    jsr BASIC_STROUT	; output type
    
    ; Restore 0/Zero-Page
	pla
    sta Ptr1+1
    pla
    sta Ptr1
    
    jmp .next
    
; ------------------------------------------------------------
;  Add 8-bit (7) to the 16-bit value located at Ptr1
; ------------------------------------------------------------
.add7:
    clc				; Clear carry before add
    lda Ptr1
    adc #7			; Add 7 to LSB
    sta Ptr1
    bcc .skip		; Branch if carry is clear
    inc Ptr1 + 1	; Adjust carry for MSB
.skip:
    rts
    
; ------------------------------------------------------------
; Adds the 16-bit value pointed to by (Ptr1) to Ptr1 itself
; ------------------------------------------------------------
; On entry:
;   Ptr1 = pointer (e.g. $1234)
;   ($1234) = 16-bit value to add (e.g. $000A)
; On exit:
;   Ptr1 = Ptr1 + ($1234)
; ------------------------------------------------------------
.addtoPtr1:
    ; Dereference Ptr1
    ldy #2			; index to 16-bit value (size/length)
    lda (Ptr1),y	; lsb
    sta Ptr3
    iny
    lda (Ptr1),y	; msb
    sta Ptr3+1

    ; Add Ptr3 to Ptr1
    clc
    lda Ptr1		; lsb
    adc Ptr3
    sta Ptr1
    
    lda Ptr1+1		; msb
    adc Ptr3+1
    sta Ptr1+1
    rts

; ------------------------------------------------------------
; Project source code
; ------------------------------------------------------------
!src "dvsa.a"
!src "dasa.a"
}


    