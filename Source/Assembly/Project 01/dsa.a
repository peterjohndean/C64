; ------------------------------------------------------------
;  BASIC Variable/Array Storage Area
;  ------------------------------------------------------------
;  Dumps the BASIC variable/array names and type.
;	- VARTAB to ARYTAB (Each entry is 7 bytes)
;	- ARYTAB to STREND (Each entry varys in length)
; ------------------------------------------------------------

!zone DUMPBASICSTORAGEAREA {
;
; Workspace
; Variable/Array Information
!address VarIndx	!word 0				; Variable index
!address VarAddr	= <MM_FREKZP		; Variable address
!address VarName	!byte ' ', ' ', 0	; Variable name, null-terminated.
;!address VarType	!byte ' ', 0		; Variable type, null-terminated.
;!address VarDim		!byte 0				; Variable DIM. i.e. A(x) → 1, A(x,y) → 2, A(x,y,z) → 3
;!address VarDimRsv	!word 0				; Variable DIM reserved, default is 10 +1
!address PFTmp:		!byte $00, $00, $00, $00, $00	; Temporary Packed Float
;
!address Ptr2 	!word 0
!address Ptr3	!word 0			; Temporary 16-bit value.
!address Bool	!byte 0			; 0 = VARTAB, else ARYTAB
!address Type	!byte 0			; Default type = float

;
; Constants
; C64 Packed Floating-point
!address PF07:	!byte $83, $60, $00, $00, $00	; Value = 7.0
;
; Variable/Array Types
!address .STRfloat	!pet "  (float)", 0
!address .STRstring	!pet "$ (string)", 0
!address .STRint	!pet "% (integer)", 0
!address .STRfn		!pet "  (function)", 0
!address .STRTable	!word .STRfloat, .STRstring, .STRfn, .STRint	; Sequence is important!

;
EntryPoint_DBSA
	jsr DVSA			; Output variable storage area
    jsr BASIC_GOCR		; Output Newline
	jsr DASA			; Output array storage area
	
ExitPoint_DBSA:
	rts
	
; Very simple dump variable name table
DumpTable:
; Main loop
.loop:
	+CMP16 VarAddr, Ptr2
	bcs ExitPoint_DBSA	; Exit, if VarAddr ≥ Ptr2
	
.cont:
    ; Is two character name?
    ldy #1
    lda (VarAddr),y
    and #$7f			; Handle $80 as terminator
    beq .No2ndChar		; Branch if 0 OR $80
    
    ; Handle two character name
    dey
    lda (VarAddr),y
    and #$7f
    sta VarName
    iny
    lda (VarAddr),y
    and #$7f
    sta VarName+1

    jmp .next
    
.No2ndChar
	; Handle single character name
	lda #' '
	sta VarName
    dey
    lda (VarAddr),y
    and #$7f
    sta VarName+1
    
.next:
	; Output variable index
    +BASIC_LINPRT_MEM VarIndx
	+KERNEL_CHROUT_IMM '.'
	+KERNEL_CHROUT_IMM ' '

	; Output variable address
	+KERNEL_CHROUT_IMM '['
	+OUTPUT_HEXWORD VarAddr
    +KERNEL_CHROUT_IMM ']'
    +KERNEL_CHROUT_IMM ' '
    
    ; Output variable name
	+BASIC_STROUT_IMM VarName
	
	jsr TypeDetect				; Now what type of variable is it?
	
	inc VarIndx			; Increment variable sequence index
    jsr BASIC_GOCR		; Newline

	; Handle Variables & Arrays differently
	lda Bool
	bne .ARYTAB			; Bool == 0, fallthrough to .VARTAB, else branch to .ARYTAB
	
.VARTAB:
    jsr .add7
    jmp .loop
    
.ARYTAB:
	jsr .addtoVarAddr
    jmp .loop
    
; ------------------------------------------------------------
;  BASIC storage variable type
; ------------------------------------------------------------ 
; VarAddr		VarAddr+1
; LSB		MSB	
; & $80		& $80	Index	ID	BASIC Variable Type
; 0			0		0 (00)		Float
; 0			1		1 (01)	$	String
; 1			0		2 (10)		Function
; 1			1		3 (11)	%	Integer	
; ------------------------------------------------------------
TypeDetect:
    ; Calculate type index (0-3) and multiply by 2 for word/vector table
    ldy #0
    lda (VarAddr),y
    and #$80
    rol             ; Shift LSB bit 7 into carry
    				; Reference:
    				; - pg 3-85, 6502 Assembly Language Programming, 1979, Lance A. Leventhal
    				; - pg64-65,pg259, 6502 Software Design, 1980, Leo J. Scanlon
    ldy #1  
    lda (VarAddr),y
    and #$80
    rol             ; Shift MSB bit 7 into carry, previous carry into bit 0
    rol             ; Now A contains 0-3
    and #$03
    sta Type		; Store variable type
    asl             ; Multiply by 2 for word table index
    tay
    
    ; Preserve 0/Zero-Page
    lda VarAddr
    pha
    lda VarAddr+1
    pha
    
    ; Look up string pointer from vector table
    lda .STRTable,y		; lsb
    pha
    lda .STRTable+1,y	; msb
    tay
    pla
    jsr BASIC_STROUT	; output type
    
    ; Restore 0/Zero-Page
	pla
    sta VarAddr+1
    pla
    sta VarAddr
    
    rts
;    jmp .next
    
; ------------------------------------------------------------
;  Add 8-bit (7) to the 16-bit value located at VarAddr
; ------------------------------------------------------------
.add7:
    clc				; Clear carry before add
    lda VarAddr
    adc #7			; Add 7 to LSB
    sta VarAddr
    bcc .skip		; Branch if carry is clear
    inc VarAddr + 1	; Adjust carry for MSB
.skip:
    rts
    
; ------------------------------------------------------------
; Adds the 16-bit value pointed to by (VarAddr) to VarAddr itself
; ------------------------------------------------------------
; On entry:
;   VarAddr = pointer (e.g. $1234)
;   ($1234) = 16-bit value to add (e.g. $000A)
; On exit:
;   VarAddr = VarAddr + ($1234)
; ------------------------------------------------------------
.addtoVarAddr:
    ; Dereference VarAddr
    ldy #2			; index to 16-bit value (size/length)
    lda (VarAddr),y	; lsb
    sta Ptr3
    iny
    lda (VarAddr),y	; msb
    sta Ptr3+1

    ; Add Ptr3 to VarAddr
    clc
    lda VarAddr		; lsb
    adc Ptr3
    sta VarAddr
    
    lda VarAddr+1	; msb
    adc Ptr3+1
    sta VarAddr+1
    rts

; ------------------------------------------------------------
; Project source code
; ------------------------------------------------------------
!src "dvsa.a"
!src "dasa.a"
}


    