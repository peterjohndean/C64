;
; Check if anything is in the storage area,
; if so dump what it finds.
;
!zone DVSA {
; Constants
!address .HDR1  !pet "basic variable storage", 13, 0
!address .HDR2	!pet "] (", 0
; Packed Floating-point constants in C64 format
;!address Float0:	!byte $00, $00, $00, $00, $00	; 0.0
;!address Float1:    !byte $81,$00,$00,$00,$00  ; 1.0
;!address Float2:    !byte $82,$00,$00,$00,$00  ; 2.0  
;!address Float7:	!byte $83, $60, $00, $00, $00	; 7.0
;!address Float10:	!byte $84, $20,$00, $00,$00	; 10.0
;!address Float63:	!byte $86, $7c, $00, $00, $00   ; 63.0
;!address FloatTmp:	!byte $00, $00, $00, $00, $00

DVSA:
	; Is BASIC variable storage empty?
	+CMP16 MM_VARTAB, MM_ARYTAB
	bne .PVSA
	rts
	
.PVSA:
	; Initialise
    lda #1
    sta VarIndx
    
    lda #0
    sta Bool
    
    ; Header
    +BASIC_STROUT_IMM .HDR1
	
    ; Location [xxxx-yyyy]
    +KERNEL_CHROUT_IMM '['
    +OUTPUT_HEXWORD MM_VARTAB			; Address Start
    +KERNEL_CHROUT_IMM '-'
    +SUB16_IMM MM_ARYTAB, $0001, Ptr3	; Adjust End Address: Ptr3 =  MM_ARYTAB - 1
    +OUTPUT_HEXWORD Ptr3				; Address End
    +BASIC_STROUT_IMM .HDR2
	
    ; Calculate Size (bytes used)
    +SUB16 MM_ARYTAB, MM_VARTAB, Ptr3	; Ptr3 =  MM_ARYTAB - MM_VARTAB

    ;
    ; Calculate Count (number of variables)
;    +BASIC_GIVAYF_MEM Ptr3		; Ptr3 → FAC1
;	+BASIC_MOVFM_IMM PFTmp	; FAC1 → Memory
;;	+BASIC_GIVAYF_IMM $0007		; FAC1 = 7
;;	+BASIC_GIVAYF_IMM $FFF9		; FAC1 = -7
;	+BASIC_MOVMF_IMM PF07	; Memory → FAC1, aka FAC1 = 7
;	+BASIC_CONUPK_IMM PFTmp	; Memory → FAC2, aka FAC2 = Ptr3
;	jsr BASIC_FDIVT				; FAC1 = FAC2 / FAC1
;	jsr BASIC_FOUT
;	jsr BASIC_STROUT
;	+KERNEL_CHROUT_IMM ','
	
	; Calculate Count (number of variables)
	+BASIC_GIVAYF_MEM Ptr3	; Ptr3 to FAC1
	+BASIC_MOVFM_IMM PFTmp	; FAC1 → Memory
	+BASIC_MOVMF_IMM PF07	; Memory → FAC1
	+BASIC_FDIV_IMM	PFTmp	; Memory → FAC2, FAC1 = FAC2 ÷ FAC1
	
    ;
    ; Output (Count, Size)
    jsr BASIC_GETADR			; FAC1 → UINT (A/Y) → MM_LINNUM
    +BASIC_LINPRT_MEM MM_LINNUM	; Output MM_LINNUM value
    
	+KERNEL_CHROUT_IMM ','
    +KERNEL_CHROUT_IMM ' '
    +BASIC_LINPRT_MEM Ptr3		; Output Ptr3 value
    +KERNEL_CHROUT_IMM 'B'
    +KERNEL_CHROUT_IMM ')'
    jsr BASIC_GOCR				; Newline
    
	;
    ; Dump Table
    ;
    ; pseudocode
    ; while (VarAddr < Ptr2) {
    ;	get name
    ;	get type
    ;	output index. name (type)
    ;	VarAddr = VarAddr + 7 (fixed)
    ; }
    ;
    lda MM_VARTAB
    sta VarAddr
    lda MM_VARTAB + 1
    sta VarAddr + 1
    
    lda MM_ARYTAB
    sta Ptr2
    lda MM_ARYTAB + 1
    sta Ptr2 + 1
    
    jsr DumpTable
    rts
}